---
date: 2025-06-27T10:57:51+03:00
title: "TOTP, HOTP"
draft: false
author: "Иван"
cover: ""
tags: ["security", "android"]
keywords: ["2FA", "TOTP", "OTP", "HOTP"]
description: "Что такое TOTP, и какие опенсорсные приложения на Android для этого лучше"
showFullContent: false
readingTime: true
draft: false
---

## Что такое TOTP

TOTP - для двухфакторной авторизации. Вместо кода на мобильный телефон (считается небезопасным).

### Схема работы:

1. У клиента и сервера - есть общий секрет.
2. У клиента и сервера - синхронизированы часы.
3. Когда нужно авторизоваться, сервер вычисляет **HASH(T+SECRET)**. T - это количество интервалов времени (например 30-секундных) с [unix epoch](https://en.wikipedia.org/wiki/Unix_time).
4. Клиент тоже считает **HASH(T+SECRET)**.
5. Клиент и сервер берут определённым общеизвестным способом первые цифры от хэша. 
6. Клиент передаёт серверу токен, сервер делает сравнение.

### Возможные уязвимости/проблемы:
1. Может утечь общий секрет, как со стороны клиента, так и со стороны сервера. С кодами на мобильный телефон _именно этого_ не может произойти, к слову.
2. Можно перехватить одноразовый ключ.
3. Может произойти рассинхрон времени: тогда нельзя будет авторизоваться.

- [wiki](https://en.wikipedia.org/wiki/Time-based_one-time_password)
- [ru-wiki](https://ru.wikipedia.org/wiki/TOTP)

## Опенсорсные приложения для Android для TOTP.

Из лучших, рекомендуют 
- [Aegis](https://getaegis.app) (посмотрел, выглядит нормально, есть какая-то защита).
- [freeOTP+](https://github.com/helloworld1/FreeOTPPlus) (пока не смотрел, форк freeOTP).

ещё смотрел
- [secur](https://gitlab.com/ATechnoHazard/secur) - заброшенный, как плюс разве что простота интерфейса.

- [reddit](https://www.reddit.com/r/privacytoolsIO/comments/do46ic/security_of_totp_apps_on_android/) что-то про Aegis и andOTP

## Зачем

Гитхаб требует начать использовать двухфакторку от отдельных аккаунтов.

## Что такое HOTP

(2025-07-12)

Эта схема стала предшественником **TOTP**.

### Схема работы:

1. У клиента и сервера - общий секрет **SECRET**.
2. У клиента и сервера - общий счётчик **I**.
3. Когда нужно авторизоваться, сервер вычисляет **HASH(SECRET, I)**. **HASH** - описывается что SHA1, хотя и считается уязвимым к коллизиям.
4. Клиент вычисляет **HASH(SECRET, I)**.
5. Клиент и сервер выделяют общеизвестным способом цифры (6-8 цифр) из полученного хэша.
6. Клиент посылает цифры на сервер.
7. Происходит сравнение, если совпало - успех.
8. При **успешной авторизации** - происходит инкремент счётчика сервера.
9. В любом случае - происходит инкремент счётчика клиента.

### Рассинхронизация

Допустима ситуация, когда у клиента счётчик больше, чем у сервера. (Т.к. условия инкремента счётчика отличаются). Тогда сервер вычисляет несколько кодов "вперёд" (например, для I+1, I+2, ... I+5), и если хоть один из них совпадает - авторизация также проходит успешно. Происходит _ресинхронизация_, см. ниже детали.

### Ресинхронизация

(похожее название).

Если _рассинхронизация_ происходит, то при _ресинхронизации_ (процессе установления счётчиков в одинаковое число) может быть также запрошено согласно стандарту ещё несколько кодов от клиента (чтобы атакующий не мог положиться на "достаточно чтобы мой рандомный код совпал с одним из 6 кодов, а не только с 1").

После успеха счётчик сервера устанавливается равный счётчику клиента.

### Возможные вектора атаки

(to be continued)

### Ссылки

- (для деталей и уточнений) [RFC 4226](https://datatracker.ietf.org/doc/html/rfc4226)
- (менее полезное в случае непонимания) [ру-вики](https://ru.wikipedia.org/wiki/HOTP), [en-wiki](https://en.wikipedia.org/wiki/HOTP)
