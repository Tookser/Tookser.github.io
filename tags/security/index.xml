<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>security on Личный сайт Ивана Белашкина</title><link>https://tookser.github.io/tags/security/</link><description>Recent content in security on Личный сайт Ивана Белашкина</description><generator>Hugo -- gohugo.io</generator><language>ru-ru</language><lastBuildDate>Wed, 12 Nov 2025 22:13:08 +0300</lastBuildDate><atom:link href="https://tookser.github.io/tags/security/index.xml" rel="self" type="application/rss+xml"/><item><title>Инструкция: как мигрировать БД из PasswordSafe в KeePassXC</title><link>https://tookser.github.io/posts/passwordsafe_to_keepassxc_migration/</link><pubDate>Wed, 12 Nov 2025 22:13:08 +0300</pubDate><guid>https://tookser.github.io/posts/passwordsafe_to_keepassxc_migration/</guid><description>Что и зачем KeePassXC - опенсорсный парольный менеджер, он хранит пароли. Он гораздо функциональнее и удобнее, чем PasswordSafe.
Чтобы перейти из одного в другой, сохранив пароли - нужна миграция БД из PasswordSafe в KeePassXC.
Ориентировался на эту инструкцию, но упростил из-за апдейтов программы.
Подготовка Создаём RAM-диск: sudo mkdir /mnt/NAME sudo mount -o size=10M -t tmpfs tmpfs /mnt/NAME (он должен исчезнуть после перезагрузки).
Устанавливаем KeePass2x. (он понадобится для промежуточного этапа переноса).</description><content>&lt;h2 id="что-и-зачем">Что и зачем&lt;/h2>
&lt;p>&lt;code>KeePassXC&lt;/code> - опенсорсный парольный менеджер, он хранит пароли. Он гораздо функциональнее и удобнее, чем &lt;code>PasswordSafe&lt;/code>.&lt;/p>
&lt;p>Чтобы перейти из одного в другой, сохранив пароли - нужна миграция БД из &lt;code>PasswordSafe&lt;/code> в &lt;code>KeePassXC&lt;/code>.&lt;/p>
&lt;p>Ориентировался на &lt;a href="https://infosec.press/ktneely/migrating-passwordsafe-to-keepassxc">эту инструкцию&lt;/a>, но упростил из-за апдейтов программы.&lt;/p>
&lt;h2 id="подготовка">Подготовка&lt;/h2>
&lt;ul>
&lt;li>Создаём RAM-диск:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">sudo mkdir /mnt/NAME
sudo mount -o size&lt;span style="color:#f92672">=&lt;/span>10M -t tmpfs tmpfs /mnt/NAME
&lt;/code>&lt;/pre>&lt;/div>&lt;p>(он должен исчезнуть после перезагрузки).&lt;/p>
&lt;ul>
&lt;li>Устанавливаем &lt;a href="https://keepass.info/help/v2/setup.html">KeePass2x&lt;/a>. (он понадобится для промежуточного этапа переноса).&lt;/li>
&lt;li>Устанавливаем &lt;a href="https://keepassxc.org/">KeePassXC&lt;/a>.&lt;/li>
&lt;/ul>
&lt;h2 id="шаги">&lt;strong>Шаги:&lt;/strong>&lt;/h2>
&lt;ol>
&lt;li>Экспортируем из PasswordSafe в формате .xml &lt;em>RAM-диск&lt;/em>. (в примере &lt;code>/mnt/NAME&lt;/code>) Сохраняем все поля.&lt;/li>
&lt;li>В KeePass2x, создаём шифрованную БД (не рекомендую использовать тот же пароль, что был в PS), уже на обычном диске. Файл должен получить расширение &lt;code>.kdbx&lt;/code>.&lt;/li>
&lt;li>(Опционально) Рекомендуется удалить sample entries, чтобы не отвлекали (2 демонстрационных &lt;code>entry&lt;/code>, которые есть в новой базе).&lt;/li>
&lt;li>В KeePass2x, импортируем с диска в оперативной памяти (формат импорта - PasswordSafe XML).&lt;/li>
&lt;li>Уже в KeePassXC открываем БД, созданную ранее.&lt;/li>
&lt;li>Удаляем файлы &lt;em>RAM-диск&lt;/em> (&lt;code>/mnt/NAME&lt;/code>).&lt;/li>
&lt;/ol>
&lt;p>(Для проверки можно посмотреть &lt;code>Database -&amp;gt; Database Reports...&lt;/code> и посмотреть на Number of Entries, оно будет тем же, что и в PasswordSafe.)&lt;/p></content></item><item><title>TOTP, HOTP</title><link>https://tookser.github.io/posts/otp/</link><pubDate>Fri, 27 Jun 2025 10:57:51 +0300</pubDate><guid>https://tookser.github.io/posts/otp/</guid><description>Что такое TOTP TOTP - для двухфакторной авторизации. Вместо кода на мобильный телефон (считается небезопасным).
Схема работы: У клиента и сервера - есть общий секрет. У клиента и сервера - синхронизированы часы. Когда нужно авторизоваться, сервер вычисляет HASH(T+SECRET). T - это количество интервалов времени (например 30-секундных) с unix epoch. Клиент тоже считает HASH(T+SECRET). Клиент и сервер берут определённым общеизвестным способом первые цифры от хэша. Клиент передаёт серверу токен, сервер делает сравнение.</description><content>&lt;h2 id="что-такое-totp">Что такое TOTP&lt;/h2>
&lt;p>TOTP - для двухфакторной авторизации. Вместо кода на мобильный телефон (считается небезопасным).&lt;/p>
&lt;h3 id="схема-работы">Схема работы:&lt;/h3>
&lt;ol>
&lt;li>У клиента и сервера - есть общий секрет.&lt;/li>
&lt;li>У клиента и сервера - синхронизированы часы.&lt;/li>
&lt;li>Когда нужно авторизоваться, сервер вычисляет &lt;strong>HASH(T+SECRET)&lt;/strong>. T - это количество интервалов времени (например 30-секундных) с &lt;a href="https://en.wikipedia.org/wiki/Unix_time">unix epoch&lt;/a>.&lt;/li>
&lt;li>Клиент тоже считает &lt;strong>HASH(T+SECRET)&lt;/strong>.&lt;/li>
&lt;li>Клиент и сервер берут определённым общеизвестным способом первые цифры от хэша.&lt;/li>
&lt;li>Клиент передаёт серверу токен, сервер делает сравнение.&lt;/li>
&lt;/ol>
&lt;h3 id="возможные-уязвимостипроблемы">Возможные уязвимости/проблемы:&lt;/h3>
&lt;ol>
&lt;li>Может утечь общий секрет, как со стороны клиента, так и со стороны сервера. С кодами на мобильный телефон &lt;em>именно этого&lt;/em> не может произойти, к слову.&lt;/li>
&lt;li>Можно перехватить одноразовый ключ.&lt;/li>
&lt;li>Может произойти рассинхрон времени: тогда нельзя будет авторизоваться.&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Time-based_one-time_password">wiki&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://ru.wikipedia.org/wiki/TOTP">ru-wiki&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="опенсорсные-приложения-для-android-для-totp">Опенсорсные приложения для Android для TOTP.&lt;/h2>
&lt;p>Из лучших, рекомендуют&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://getaegis.app">Aegis&lt;/a> (посмотрел, выглядит нормально, есть какая-то защита).&lt;/li>
&lt;li>&lt;a href="https://github.com/helloworld1/FreeOTPPlus">freeOTP+&lt;/a> (пока не смотрел, форк freeOTP).&lt;/li>
&lt;/ul>
&lt;p>ещё смотрел&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://gitlab.com/ATechnoHazard/secur">secur&lt;/a> - заброшенный, как плюс разве что простота интерфейса.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.reddit.com/r/privacytoolsIO/comments/do46ic/security_of_totp_apps_on_android/">reddit&lt;/a> что-то про Aegis и andOTP&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="зачем">Зачем&lt;/h2>
&lt;p>Гитхаб требует начать использовать двухфакторку от отдельных аккаунтов.&lt;/p>
&lt;h2 id="что-такое-hotp">Что такое HOTP&lt;/h2>
&lt;p>(2025-07-12)&lt;/p>
&lt;p>Эта схема стала предшественником &lt;strong>TOTP&lt;/strong>.&lt;/p>
&lt;h3 id="схема-работы-1">Схема работы:&lt;/h3>
&lt;ol>
&lt;li>У клиента и сервера - общий секрет &lt;strong>SECRET&lt;/strong>.&lt;/li>
&lt;li>У клиента и сервера - общий счётчик &lt;strong>I&lt;/strong>.&lt;/li>
&lt;li>Когда нужно авторизоваться, сервер вычисляет &lt;strong>HASH(SECRET, I)&lt;/strong>. &lt;strong>HASH&lt;/strong> - описывается что SHA1, хотя и считается уязвимым к коллизиям.&lt;/li>
&lt;li>Клиент вычисляет &lt;strong>HASH(SECRET, I)&lt;/strong>.&lt;/li>
&lt;li>Клиент и сервер выделяют общеизвестным способом цифры (6-8 цифр) из полученного хэша.&lt;/li>
&lt;li>Клиент посылает цифры на сервер.&lt;/li>
&lt;li>Происходит сравнение, если совпало - успех.&lt;/li>
&lt;li>При &lt;strong>успешной авторизации&lt;/strong> - происходит инкремент счётчика сервера.&lt;/li>
&lt;li>В любом случае - происходит инкремент счётчика клиента.&lt;/li>
&lt;/ol>
&lt;h3 id="рассинхронизация">Рассинхронизация&lt;/h3>
&lt;p>Допустима ситуация, когда у клиента счётчик больше, чем у сервера. (Т.к. условия инкремента счётчика отличаются). Тогда сервер вычисляет несколько кодов &amp;ldquo;вперёд&amp;rdquo; (например, для I+1, I+2, &amp;hellip; I+5), и если хоть один из них совпадает - авторизация также проходит успешно. Происходит &lt;em>ресинхронизация&lt;/em>, см. ниже детали.&lt;/p>
&lt;h3 id="ресинхронизация">Ресинхронизация&lt;/h3>
&lt;p>(похожее название).&lt;/p>
&lt;p>Если &lt;em>рассинхронизация&lt;/em> происходит, то при &lt;em>ресинхронизации&lt;/em> (процессе установления счётчиков в одинаковое число) может быть также запрошено согласно стандарту ещё несколько кодов от клиента (чтобы атакующий не мог положиться на &amp;ldquo;достаточно чтобы мой рандомный код совпал с одним из 6 кодов, а не только с 1&amp;rdquo;).&lt;/p>
&lt;p>После успеха счётчик сервера устанавливается равный счётчику клиента.&lt;/p>
&lt;h3 id="возможные-вектора-атаки">Возможные вектора атаки&lt;/h3>
&lt;p>(to be continued)&lt;/p>
&lt;h3 id="ссылки">Ссылки&lt;/h3>
&lt;ul>
&lt;li>(для деталей и уточнений) &lt;a href="https://datatracker.ietf.org/doc/html/rfc4226">RFC 4226&lt;/a>&lt;/li>
&lt;li>(менее полезное в случае непонимания) &lt;a href="https://ru.wikipedia.org/wiki/HOTP">ру-вики&lt;/a>, &lt;a href="https://en.wikipedia.org/wiki/HOTP">en-wiki&lt;/a>&lt;/li>
&lt;/ul></content></item></channel></rss>