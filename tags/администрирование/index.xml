<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>администрирование on Личный сайт Ивана Белашкина</title><link>https://tookser.github.io/tags/%D0%B0%D0%B4%D0%BC%D0%B8%D0%BD%D0%B8%D1%81%D1%82%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/</link><description>Recent content in администрирование on Личный сайт Ивана Белашкина</description><generator>Hugo -- gohugo.io</generator><language>ru-ru</language><lastBuildDate>Wed, 12 Nov 2025 22:13:08 +0300</lastBuildDate><atom:link href="https://tookser.github.io/tags/%D0%B0%D0%B4%D0%BC%D0%B8%D0%BD%D0%B8%D1%81%D1%82%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/index.xml" rel="self" type="application/rss+xml"/><item><title>Инструкция: как мигрировать БД из PasswordSafe в KeePassXC</title><link>https://tookser.github.io/posts/passwordsafe_to_keepassxc_migration/</link><pubDate>Wed, 12 Nov 2025 22:13:08 +0300</pubDate><guid>https://tookser.github.io/posts/passwordsafe_to_keepassxc_migration/</guid><description>Что и зачем KeePassXC - опенсорсный парольный менеджер, он хранит пароли. Он гораздо функциональнее и удобнее, чем PasswordSafe.
Чтобы перейти из одного в другой, сохранив пароли - нужна миграция БД из PasswordSafe в KeePassXC.
Ориентировался на эту инструкцию, но упростил из-за апдейтов программы.
Подготовка Создаём RAM-диск: sudo mkdir /mnt/NAME sudo mount -o size=10M -t tmpfs tmpfs /mnt/NAME (он должен исчезнуть после перезагрузки).
Устанавливаем KeePass2x. (он понадобится для промежуточного этапа переноса).</description><content>&lt;h2 id="что-и-зачем">Что и зачем&lt;/h2>
&lt;p>&lt;code>KeePassXC&lt;/code> - опенсорсный парольный менеджер, он хранит пароли. Он гораздо функциональнее и удобнее, чем &lt;code>PasswordSafe&lt;/code>.&lt;/p>
&lt;p>Чтобы перейти из одного в другой, сохранив пароли - нужна миграция БД из &lt;code>PasswordSafe&lt;/code> в &lt;code>KeePassXC&lt;/code>.&lt;/p>
&lt;p>Ориентировался на &lt;a href="https://infosec.press/ktneely/migrating-passwordsafe-to-keepassxc">эту инструкцию&lt;/a>, но упростил из-за апдейтов программы.&lt;/p>
&lt;h2 id="подготовка">Подготовка&lt;/h2>
&lt;ul>
&lt;li>Создаём RAM-диск:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">sudo mkdir /mnt/NAME
sudo mount -o size&lt;span style="color:#f92672">=&lt;/span>10M -t tmpfs tmpfs /mnt/NAME
&lt;/code>&lt;/pre>&lt;/div>&lt;p>(он должен исчезнуть после перезагрузки).&lt;/p>
&lt;ul>
&lt;li>Устанавливаем &lt;a href="https://keepass.info/help/v2/setup.html">KeePass2x&lt;/a>. (он понадобится для промежуточного этапа переноса).&lt;/li>
&lt;li>Устанавливаем &lt;a href="https://keepassxc.org/">KeePassXC&lt;/a>.&lt;/li>
&lt;/ul>
&lt;h2 id="шаги">&lt;strong>Шаги:&lt;/strong>&lt;/h2>
&lt;ol>
&lt;li>Экспортируем из PasswordSafe в формате .xml &lt;em>RAM-диск&lt;/em>. (в примере &lt;code>/mnt/NAME&lt;/code>) Сохраняем все поля.&lt;/li>
&lt;li>В KeePass2x, создаём шифрованную БД (не рекомендую использовать тот же пароль, что был в PS), уже на обычном диске. Файл должен получить расширение &lt;code>.kdbx&lt;/code>.&lt;/li>
&lt;li>(Опционально) Рекомендуется удалить sample entries, чтобы не отвлекали (2 демонстрационных &lt;code>entry&lt;/code>, которые есть в новой базе).&lt;/li>
&lt;li>В KeePass2x, импортируем с диска в оперативной памяти (формат импорта - PasswordSafe XML).&lt;/li>
&lt;li>Уже в KeePassXC открываем БД, созданную ранее.&lt;/li>
&lt;li>Удаляем файлы &lt;em>RAM-диск&lt;/em> (&lt;code>/mnt/NAME&lt;/code>).&lt;/li>
&lt;/ol>
&lt;p>(Для проверки можно посмотреть &lt;code>Database -&amp;gt; Database Reports...&lt;/code> и посмотреть на Number of Entries, оно будет тем же, что и в PasswordSafe.)&lt;/p></content></item><item><title>Горячие клавиши</title><link>https://tookser.github.io/posts/hotkey/</link><pubDate>Fri, 05 May 2023 15:43:18 +0300</pubDate><guid>https://tookser.github.io/posts/hotkey/</guid><description>XFCE В линуксе (убунту) есть пакет с командой wmctrl. https://superuser.com/a/142957 тут описано, что он позволяет активировать окно по его названию. Т.е. можно сделать скриптик на bash, который по хоткею будет запускаться и либо активировать окно с обсидианом, либо — запускать его, если не был запущен
bash -c &amp;#34;wmctrl -a &amp;#39;PARTOFTITLE&amp;#39; || /full/path/to/program&amp;#34; В xfce нужно создать сочетание для горячих клавиш (Settings-&amp;gt;Keyboard-&amp;gt;Application Shortcuts). Вместо 'PARTOFTITLE' подставить часть заголовка окна программы, вместо '/full/path/to/program' подставить полный путь к программе.</description><content>&lt;h3 id="xfce">XFCE&lt;/h3>
&lt;p>В линуксе (убунту) есть пакет с командой wmctrl. &lt;a href="https://superuser.com/a/142957">https://superuser.com/a/142957&lt;/a> тут описано, что он позволяет активировать окно по его названию. Т.е. можно сделать скриптик на bash, который по хоткею будет запускаться и либо активировать окно с обсидианом, либо — запускать его, если не был запущен&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">bash -c &lt;span style="color:#e6db74">&amp;#34;wmctrl -a &amp;#39;PARTOFTITLE&amp;#39; || /full/path/to/program&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>В xfce нужно создать сочетание для горячих клавиш (Settings-&amp;gt;Keyboard-&amp;gt;Application Shortcuts). Вместо &lt;code>'PARTOFTITLE'&lt;/code> подставить часть заголовка окна программы, вместо &lt;code>'/full/path/to/program'&lt;/code> подставить полный путь к программе.&lt;/p>
&lt;h3 id="принцип-работы">Принцип работы&lt;/h3>
&lt;p>Происходящее работает так:&lt;/p>
&lt;p>Происходит попытка активации окна, если она успешна - вторая командна не выполняется. Если не успешна - выполняется вторая команда. &lt;code>||&lt;/code> это ленивый оператор OR, который выполняет вторую команду, только если первая завершилась ошибкой (код завершения != &lt;code>0&lt;/code>). Есть ещё &lt;code>&amp;amp;&amp;amp;&lt;/code> - ленивый оператор AND.&lt;/p>
&lt;h3 id="kde">KDE&lt;/h3>
&lt;p>На КДЕ такое. -x, и на всякий случай класс (-R) - уникальнее. На xfce через классы не смог сделать.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">wmctrl -x -R firefox &lt;span style="color:#f92672">||&lt;/span> snap run firefox
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>xprop WM_CLASS&lt;/code> и клик по окну - для узнавания класса.&lt;/p></content></item><item><title>ModernCV и мытарства</title><link>https://tookser.github.io/posts/moderncv/</link><pubDate>Fri, 15 Apr 2022 14:51:22 +0300</pubDate><guid>https://tookser.github.io/posts/moderncv/</guid><description>Для справки, LaTeX - система вёрстки, обычно для научных статей, Docker - система для контейнеризации (нечто вроде виртуальной машины).
Немного предыстории. ModernCV - шаблон для LaTeX, позволяющий писать красивенькие резюме в pdf. Требует небольшого знания LaTeX-а. В документации можно посмотреть, как выглядит.
Этот шаблон почему-то упорно не хотел нормально собираться на моей системе, и в итоге нашлось более хорошее решение.
Вот ссылка на docker-образ образ докера с texlive. В нём это резюме собирается следующим образом (рассказываю вариант под Linux с установленным Docker).</description><content>&lt;p>Для справки, &lt;strong>LaTeX&lt;/strong> - система вёрстки, обычно для научных статей, &lt;strong>Docker&lt;/strong> - система для контейнеризации (нечто вроде виртуальной машины).&lt;/p>
&lt;p>Немного предыстории. &lt;strong>&lt;a href="https://github.com/moderncv/moderncv">ModernCV&lt;/a>&lt;/strong> - шаблон для LaTeX, позволяющий писать красивенькие резюме в pdf. Требует небольшого знания LaTeX-а. В &lt;a href="https://github.com/moderncv/moderncv/raw/master/manual/moderncv_userguide.pdf">документации&lt;/a> можно посмотреть, как выглядит.&lt;/p>
&lt;p>Этот шаблон почему-то упорно не хотел нормально собираться на моей системе, и в итоге нашлось более хорошее решение.&lt;/p>
&lt;p>Вот &lt;a href="https://github.com/moderncv/debian-texlive-docker/pkgs/container/debian-texlive-docker">ссылка на docker-образ&lt;/a> образ докера с texlive. В нём это резюме собирается следующим образом (рассказываю вариант под Linux с установленным Docker).&lt;/p>
&lt;p>Сначала&lt;/p>
&lt;p>&lt;code>docker pull ghcr.io/moderncv/debian-texlive-docker:main&lt;/code> - скачивание docker-образа.&lt;/p>
&lt;p>Потом создаём контейнер&lt;/p>
&lt;p>&lt;code>docker run -it -v &amp;quot;/путь/к/папке/с/резюме:/mnt&amp;quot; --name ИмяОбраза ghcr.io/moderncv/debian-texlive-docker:main /bin/bash&lt;/code>&lt;/p>
&lt;p>Это создаёт docker-контейнер по скачанному docker-образу И запускает его. &lt;em>ИмяОбраза&lt;/em> и &lt;em>/путь/к/папке/с/резюме&lt;/em> (на вашем диске) нужно заполнить самим. &lt;code>-it&lt;/code> позволяет работать в терминале внутри контейнера, &lt;code>-v&lt;/code> монтирует папку к пути &lt;code>/mnt&lt;/code> &lt;em>внутри&lt;/em> докер-контейнера (то есть с папкой &lt;code>/mnt&lt;/code> исходной системы ничего не происходит).&lt;/p>
&lt;p>Теперь нужно выполнить команду&lt;/p>
&lt;p>&lt;code>docker start ИмяКонтейнера&lt;/code>&lt;/p>
&lt;p>и&lt;/p>
&lt;p>&lt;code>docker exec -it ИмяКонтейнера /bin/bash&lt;/code>&lt;/p>
&lt;p>. Вы окажетесь в терминале, откуда уже можно собрать резюме с помощью TexLive, зайдя в директорию &lt;code>/mount&lt;/code>. Возможно, понадобится что-то догрузить из пакетов - &lt;code>apt install ...&lt;/code> (без &lt;code>sudo&lt;/code> почему-то в этом образе работает) вполне помогало, если вообще понадобилось.&lt;/p>
&lt;p>В конце можно остановить контейнер с помощью&lt;/p>
&lt;p>&lt;code>docker stop ИмяКонтейнера&lt;/code>&lt;/p>
&lt;p>.&lt;/p>
&lt;p>При повторных использованиях всё так же, начиная с команды&lt;/p>
&lt;p>&lt;code>docker start ИмяКонтейнера&lt;/code>&lt;/p>
&lt;p>.&lt;/p>
&lt;p>Два момента:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>блокируется доступ&lt;/strong> на запись к файлам в монтируемой папке, что неудобно.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>судя по всему, можно автоматизировать.&lt;/p>
&lt;/li>
&lt;/ul></content></item><item><title>Проблема с загрузкой css-stylesheet на хостинге github pages</title><link>https://tookser.github.io/posts/css/</link><pubDate>Tue, 16 Nov 2021 22:24:00 +0300</pubDate><guid>https://tookser.github.io/posts/css/</guid><description>Заметил, что на моём сайте не работают стили, хотя они есть, и показалось, что они хотят грузиться через http, хотя у меня https на сайте. Посмотрел - похоже, так и есть, и изменил в hugo схему в адресе сайта на https. Посмотрим, что получится. UPD: да, всё работает корректно. Включения по http в https-странице блокируются современными браузерами.</description><content>&lt;p>Заметил, что на моём сайте не работают стили, хотя они есть, и &lt;em>показалось&lt;/em>, что они хотят грузиться через http, хотя у меня https на сайте. Посмотрел - похоже, так и есть, и изменил в hugo схему в адресе сайта на https. Посмотрим, что получится. UPD: да, всё работает корректно. Включения по http в https-странице блокируются современными браузерами.&lt;/p></content></item></channel></rss>