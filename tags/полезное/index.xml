<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>полезное on Личный сайт Ивана Белашкина</title><link>https://tookser.github.io/tags/%D0%BF%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D0%BE%D0%B5/</link><description>Recent content in полезное on Личный сайт Ивана Белашкина</description><generator>Hugo -- gohugo.io</generator><language>ru-ru</language><lastBuildDate>Wed, 12 Nov 2025 22:13:08 +0300</lastBuildDate><atom:link href="https://tookser.github.io/tags/%D0%BF%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D0%BE%D0%B5/index.xml" rel="self" type="application/rss+xml"/><item><title>Инструкция: как мигрировать БД из PasswordSafe в KeePassXC</title><link>https://tookser.github.io/posts/passwordsafe_to_keepassxc_migration/</link><pubDate>Wed, 12 Nov 2025 22:13:08 +0300</pubDate><guid>https://tookser.github.io/posts/passwordsafe_to_keepassxc_migration/</guid><description>Что и зачем KeePassXC - опенсорсный парольный менеджер, он хранит пароли. Он гораздо функциональнее и удобнее, чем PasswordSafe.
Чтобы перейти из одного в другой, сохранив пароли - нужна миграция БД из PasswordSafe в KeePassXC.
Ориентировался на эту инструкцию, но упростил из-за апдейтов программы.
Подготовка Создаём RAM-диск: sudo mkdir /mnt/NAME sudo mount -o size=10M -t tmpfs tmpfs /mnt/NAME (он должен исчезнуть после перезагрузки).
Устанавливаем KeePass2x. (он понадобится для промежуточного этапа переноса).</description><content>&lt;h2 id="что-и-зачем">Что и зачем&lt;/h2>
&lt;p>&lt;code>KeePassXC&lt;/code> - опенсорсный парольный менеджер, он хранит пароли. Он гораздо функциональнее и удобнее, чем &lt;code>PasswordSafe&lt;/code>.&lt;/p>
&lt;p>Чтобы перейти из одного в другой, сохранив пароли - нужна миграция БД из &lt;code>PasswordSafe&lt;/code> в &lt;code>KeePassXC&lt;/code>.&lt;/p>
&lt;p>Ориентировался на &lt;a href="https://infosec.press/ktneely/migrating-passwordsafe-to-keepassxc">эту инструкцию&lt;/a>, но упростил из-за апдейтов программы.&lt;/p>
&lt;h2 id="подготовка">Подготовка&lt;/h2>
&lt;ul>
&lt;li>Создаём RAM-диск:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">sudo mkdir /mnt/NAME
sudo mount -o size&lt;span style="color:#f92672">=&lt;/span>10M -t tmpfs tmpfs /mnt/NAME
&lt;/code>&lt;/pre>&lt;/div>&lt;p>(он должен исчезнуть после перезагрузки).&lt;/p>
&lt;ul>
&lt;li>Устанавливаем &lt;a href="https://keepass.info/help/v2/setup.html">KeePass2x&lt;/a>. (он понадобится для промежуточного этапа переноса).&lt;/li>
&lt;li>Устанавливаем &lt;a href="https://keepassxc.org/">KeePassXC&lt;/a>.&lt;/li>
&lt;/ul>
&lt;h2 id="шаги">&lt;strong>Шаги:&lt;/strong>&lt;/h2>
&lt;ol>
&lt;li>Экспортируем из PasswordSafe в формате .xml &lt;em>RAM-диск&lt;/em>. (в примере &lt;code>/mnt/NAME&lt;/code>) Сохраняем все поля.&lt;/li>
&lt;li>В KeePass2x, создаём шифрованную БД (не рекомендую использовать тот же пароль, что был в PS), уже на обычном диске. Файл должен получить расширение &lt;code>.kdbx&lt;/code>.&lt;/li>
&lt;li>(Опционально) Рекомендуется удалить sample entries, чтобы не отвлекали (2 демонстрационных &lt;code>entry&lt;/code>, которые есть в новой базе).&lt;/li>
&lt;li>В KeePass2x, импортируем с диска в оперативной памяти (формат импорта - PasswordSafe XML).&lt;/li>
&lt;li>Уже в KeePassXC открываем БД, созданную ранее.&lt;/li>
&lt;li>Удаляем файлы &lt;em>RAM-диск&lt;/em> (&lt;code>/mnt/NAME&lt;/code>).&lt;/li>
&lt;/ol>
&lt;p>(Для проверки можно посмотреть &lt;code>Database -&amp;gt; Database Reports...&lt;/code> и посмотреть на Number of Entries, оно будет тем же, что и в PasswordSafe.)&lt;/p></content></item><item><title>Промт-инъекция, видео Карпатого и пара быстрых моделей</title><link>https://tookser.github.io/posts/neural1/</link><pubDate>Sun, 10 Mar 2024 20:36:38 +0300</pubDate><guid>https://tookser.github.io/posts/neural1/</guid><description>Начал проходить курс &amp;ldquo;AI Safety fundamentals&amp;rdquo;, и там есть видео Андрея Карпатого про LLM. Больше половины инфы оттуда я знал, но:
идея про то, что языковые модели как класс программ ведут себя аналогично операционным системам (LLM OS). Подробности по ссылке (видео на английском). там очень классное описание возможных атак на LLM (промт-инъекций и не только), со ссылками на статьи. Понятно, что это всё прикрывается достаточно быстро. Jailbroken: How Does LLM Safety Training Fail?</description><content>&lt;p>Начал проходить курс &amp;ldquo;AI Safety fundamentals&amp;rdquo;, и там есть &lt;a href="https://www.youtube.com/watch?v=zjkBMFhNj_g">видео Андрея Карпатого про LLM&lt;/a>. Больше половины инфы оттуда я знал, но:&lt;/p>
&lt;ul>
&lt;li>идея про то, что языковые модели как класс программ ведут себя аналогично операционным системам (&lt;em>LLM OS&lt;/em>). Подробности по &lt;a href="https://www.youtube.com/watch?v=zjkBMFhNj_g&amp;amp;t=2535s">ссылке&lt;/a> (видео на английском).&lt;/li>
&lt;li>там очень классное описание возможных атак на LLM (промт-инъекций и не только), со ссылками на статьи. Понятно, что это всё прикрывается достаточно быстро.
&lt;ul>
&lt;li>&lt;a href="https://arxiv.org/abs/2307.02483">Jailbroken: How Does LLM Safety Training Fail?&lt;/a>
&lt;ul>
&lt;li>оттуда, например - про base64 кодирование как метод обхода. LLM умеют читать base64, но не защищены.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ещё пара статей про отдельные виды атак &lt;a href="https://www.youtube.com/watch?v=zjkBMFhNj_g&amp;amp;t=2743s">(ссылка с таймкодом на последнюю часть видео про это)&lt;/a>, в том числе на мультимодальные модели.&lt;/li>
&lt;li>&lt;a href="https://arxiv.org/abs/2307.15043">Universal and Transferable Adversarial Attacks on Aligned Language Models&lt;/a> - про универсальный, выглядящий набором мусора промт-суффикс. Это надо смотреть.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="пара-ныне-недоступных-быстрых-моделей">Пара (ныне недоступных) быстрых моделей&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.ixbt.com/news/2024/02/20/nikomu-neizvestnyj-startap-groq-predstavil-vidimo-luchshij-processor-dlja-vyvoda-nejrosetevyh-modelej.html">Groq (ixbt)&lt;/a> - ASIC (специализированная микросхема) для быстрого инференса LLM. Потыкать можно &lt;a href="https://groq.com">тут,&lt;/a> (там Llama, Mistral, есть платное АПИ), это впечатляет скоростью. В какой-то момент без прокси перестало быть доступным.&lt;/li>
&lt;li>&lt;a href="https://fastsdxl.ai">https://fastsdxl.ai&lt;/a> - это быстрая генерация картинок, со скоростью ввода. Скорость достигнута в т.ч. благодаря использованию маленькой модели SD XL Lightning. Сейчас недоступна, &lt;strong>обещают вернуться.&lt;/strong>&lt;/li>
&lt;/ul></content></item><item><title>Pycharm</title><link>https://tookser.github.io/posts/pycharm/</link><pubDate>Tue, 22 Aug 2023 00:03:20 +0300</pubDate><guid>https://tookser.github.io/posts/pycharm/</guid><description>Ошибка Invalid Python Interpreter selected for the project. Понадобилось использовать Pycharm (Professional Edition).
Сначала создал проект в одной папке потом перенёс в другую. Удалил (в линуксе это требуется) подпапку с виртуальной средой venv/, создал заново. Результат - среда разработки &amp;ldquo;не подхватывается&amp;rdquo;, вылезают сообщения об ошибке с упоминанием старого пути. Решение - закрыть Pycharm PE и стереть подпапку .idea/, создаваемую pycharm-ом. При повторном открытии всё сразу подхватывается. Подозреваю, это не единственная проблема которую можно так решить.</description><content>&lt;p>Ошибка &lt;code>Invalid Python Interpreter selected for the project&lt;/code>.
Понадобилось использовать Pycharm (Professional Edition).&lt;/p>
&lt;ul>
&lt;li>Сначала создал проект в одной папке&lt;/li>
&lt;li>потом перенёс в другую.&lt;/li>
&lt;li>Удалил (в линуксе это требуется) подпапку с виртуальной средой &lt;code>venv/&lt;/code>, создал заново.&lt;/li>
&lt;li>Результат - среда разработки &amp;ldquo;не подхватывается&amp;rdquo;, вылезают сообщения об ошибке с упоминанием старого пути.&lt;/li>
&lt;/ul>
&lt;p>Решение - закрыть Pycharm PE и стереть подпапку &lt;code>.idea/&lt;/code>, создаваемую pycharm-ом. При повторном открытии всё сразу подхватывается. Подозреваю, это не единственная проблема которую можно так решить.&lt;/p></content></item><item><title>Горячие клавиши</title><link>https://tookser.github.io/posts/hotkey/</link><pubDate>Fri, 05 May 2023 15:43:18 +0300</pubDate><guid>https://tookser.github.io/posts/hotkey/</guid><description>XFCE В линуксе (убунту) есть пакет с командой wmctrl. https://superuser.com/a/142957 тут описано, что он позволяет активировать окно по его названию. Т.е. можно сделать скриптик на bash, который по хоткею будет запускаться и либо активировать окно с обсидианом, либо — запускать его, если не был запущен
bash -c &amp;#34;wmctrl -a &amp;#39;PARTOFTITLE&amp;#39; || /full/path/to/program&amp;#34; В xfce нужно создать сочетание для горячих клавиш (Settings-&amp;gt;Keyboard-&amp;gt;Application Shortcuts). Вместо 'PARTOFTITLE' подставить часть заголовка окна программы, вместо '/full/path/to/program' подставить полный путь к программе.</description><content>&lt;h3 id="xfce">XFCE&lt;/h3>
&lt;p>В линуксе (убунту) есть пакет с командой wmctrl. &lt;a href="https://superuser.com/a/142957">https://superuser.com/a/142957&lt;/a> тут описано, что он позволяет активировать окно по его названию. Т.е. можно сделать скриптик на bash, который по хоткею будет запускаться и либо активировать окно с обсидианом, либо — запускать его, если не был запущен&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">bash -c &lt;span style="color:#e6db74">&amp;#34;wmctrl -a &amp;#39;PARTOFTITLE&amp;#39; || /full/path/to/program&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>В xfce нужно создать сочетание для горячих клавиш (Settings-&amp;gt;Keyboard-&amp;gt;Application Shortcuts). Вместо &lt;code>'PARTOFTITLE'&lt;/code> подставить часть заголовка окна программы, вместо &lt;code>'/full/path/to/program'&lt;/code> подставить полный путь к программе.&lt;/p>
&lt;h3 id="принцип-работы">Принцип работы&lt;/h3>
&lt;p>Происходящее работает так:&lt;/p>
&lt;p>Происходит попытка активации окна, если она успешна - вторая командна не выполняется. Если не успешна - выполняется вторая команда. &lt;code>||&lt;/code> это ленивый оператор OR, который выполняет вторую команду, только если первая завершилась ошибкой (код завершения != &lt;code>0&lt;/code>). Есть ещё &lt;code>&amp;amp;&amp;amp;&lt;/code> - ленивый оператор AND.&lt;/p>
&lt;h3 id="kde">KDE&lt;/h3>
&lt;p>На КДЕ такое. -x, и на всякий случай класс (-R) - уникальнее. На xfce через классы не смог сделать.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">wmctrl -x -R firefox &lt;span style="color:#f92672">||&lt;/span> snap run firefox
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>xprop WM_CLASS&lt;/code> и клик по окну - для узнавания класса.&lt;/p></content></item></channel></rss>